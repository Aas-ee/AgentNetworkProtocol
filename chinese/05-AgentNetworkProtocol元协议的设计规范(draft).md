# 05-AgentNetworkProtocol元协议的设计规范

备注：
- 本章节内容为草稿阶段，后续可能会根据实际情况进行大幅调整。

## 元协议的作用

所谓的元协议，即协商通信使用协议的协议。在元协议层，我们主要参考和借鉴的是Agora Protocol（https://arxiv.org/html/2410.11905v1）。
当前的互联网世界，存在着巨大的数据孤岛现象，数据的流动集中在孤岛内容，而孤岛和孤岛之间则只有少量数据流动。
这一结果的出现，一个原因是因为互联网巨头为了最大化商业价值，另外一个是技术上的原因，互联网业务的复杂性，导致异构系统通过协议互通要付出巨大的成本。所以传统的互联网世界，只有email这一种类型的业务算得上是真正开放的业务。这里面的根本原因在于Agora Protocol论文中提出的异构网络通信的不可能三角：
- Versatility（多功能性）：支持各种应用类型的消息
- Efficiency（效率）：网络运行效率最高、成本最低
- Portability（可移植性）：支持协议修改代码最少

## 当前协议是如何协商的

一个系统如果对外提供的开发的API，一般会给出API调用示例，示例中会包含API的调用参数、返回值、使用的协议等。这个过程，就是协议协商的过程。

这个过程的缺点：
- 需要人工设计协议
- 协议的修改需要重新修改代码
- 多个系统使用api不同，需要分别进行协商和对接

使用元协议，在一定的协议基础之上，智能体网络可以通过自协商的方式，选出整个网络最优的协议，这个协议是整个网络的共识协议，大家都以此为基础，进行协作。——智能体如何选出整个网络的共识协议？


- ## 元协议的实现

LLM加持的智能体结合元协议是解决这一问题的良方：
- 智能体之间首先使用自然语言，互相沟通各自的能力、数据交换格式、使用的协议等，确定智能体之间通信的协议细节。
- 根据协商结果，智能体使用LLM构造和处理协议消息，或者使用智能体生成处理协议的代码，来构造和处理协议消息。
- 智能体之间进行协议联调，使用LLM判断协议消息是否符合协商规范，如果不符合，则通过自然语言交换进行解决。
- 最后，智能体使用最终的协议进行通信。
有了元协议的加持，智能体网络有可能会演进成一个自组织、自协商的高效协作网络，并且会诞生非常多智能体之间达成共识的通信协议，这些协议的数量将会大大超过人类制定协议的数量。


## 为什么需要协议协商

- 提高数据传输效率：在数据进入LLM之前，先进行协议协商，可以减少LLM处理的数据量，提高数据传输效率。
- 提高数据理解的准确性：通过数据源对数据结构化，而非直接让LLM处理非结构化的数据，可以提高数据理解的准确性。
- 降低数据处理复杂度：特定领域数据复杂度高，当前行业已经有大量协议规范，比如音视频流程中的数据。


## 协议协商的流程

并非所有的流程要进行协商，有些标准流程可以免协商，直接使用。


### 消息定义

协商消息基于加密消息的encryptedData进行扩展，属于加密消息的上层消息：
示例：
```json
{
  "version": "1.0",
  "type": "message",
  "timestamp": "2024-06-04T12:34:56.123Z",
  "messageId": "randomstring",
  "sourceDid": "did:example:987654321abcdefghi",
  "destinationDid": "did:example:123456789abcdefghi",
  "secretKeyId": "abc123session",
  "encryptedData": {
    "iv": "iv_encoded_base64",
    "tag": "tag_encoded_base64",
    "ciphertext": "ciphertext_encoded_base64"
  },
}
```

为了提高效率，后面所有的did相关消息全部会更改为二进制格式，现在协商消息也将使用二进制格式进行传递，这样可以减少消息的体积，提高解析效率。

加密消息encryptedData的ciphertext解密后的消息格式设计如下：

```plaintext
----------------------------------------------------------------------------------
| protocol_id (4 bytes) | protocol_version (16 bytes) |         content          |
----------------------------------------------------------------------------------
```
```

初稿：
- hello消息中，可以携带期望的协议类型、协议URL、协议版本，进行协商
- 如果协商通过，则建立连接后，直接发送协议的内容，不在进行协商过程
- 协议的数据定义，使用二进制，签名有单个字节的头，签名两bit表示协议类型：00表示元协议、01表示Debug协议、10表示实际协议，后面是具体的内容
- 扩展性：如果后面单字节无法满足需求，需要扩展，则在hello消息中添加对payload的描述

ws在很多的时候是有点复杂的。我们是把ws封装到我们的内部，在外部让用户有http类似的使用效果，即一个接口搞定一切。
还有，是否可以改造http？可能要对http的库进行改造这个工程量有点大。先基于ws跑通流程，后面可以这样考虑。


ToDo：
- 后来更多的还是以非多路复用连接为主。多路复用和非多路复用两种都可以支持。如果是服务器和服务器对接，多路复用也许效率更高。
- 先建立ws连接，然后协商秘钥，然后进行消息传递，传递消息的时候，就不用携带did、secretKeyId等字段了，他们和连接绑定
- 再进行协议的协商。如果使用标准协议，不用协商，直接发送即可；或者直接发送自然语言，这也算是标准协议的一种。
- 如果要进行协商，则发送协商消息，协商后，这个连接只收发协商的协议信息，不发送其他类型的信息
- 两个did之间协商的结果，可以进行缓存，后续直接使用缓存的结果，不用再进行协商，可以加快连接速度
- 也就是说，加密和协议协商，都是可以缓存的，都可以不用每次都进行。


设计需要考虑RTT的影响，当前协议，比如quic，已经在追求0RTT，如果我们设计的协议有很多的RTT，则需要进行优化。这里可以考虑在source hello中，携带early data(包含上次协议协商结果)，这样就可以减少RTT。

这样来看，未来的智能体网络，和现在有很大的区别。现在的互联网架构，是一个中心化的网络，比如淘宝、微信的后台系统，所有的人、店铺都连接到后台系统，然后后台系统再和外部系统进行连接。未来智能体是一个扁平的网络，人或者店铺的智能体和智能体之间直接相连，流量更加的分散、扁平。

现在最大的问题是，protocol id怎么设计，这个id是否需要全网唯一，还是两个did之间唯一


 


## 未来

未来是否所有的协议都是自然语言，所有消息的处理都使用LLM？

如果是这样的话，元协议是否还有存在的必要？

