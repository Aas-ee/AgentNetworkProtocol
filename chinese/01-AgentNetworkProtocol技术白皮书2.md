
# AgentNetworkProtocol Framework：一种用于智能体通信的协议框架

- 作者：常高伟，chgaowei@gmail.com  
- Discord: [https://discord.gg/SuXb2pzqGy](https://discord.gg/SuXb2pzqGy)  
- 官网：[https://agent-network-protocol.com/](https://agent-network-protocol.com/)  
- GitHub：[https://github.com/chgaowei/AgentNetworkProtocol](https://github.com/chgaowei/AgentNetworkProtocol)

备注：  
如果你想快速了解我们技术概要，可以先看这篇文章： [技术通俗介绍](https://egp0uc2jnx.feishu.cn/wiki/NS9qwPzNeiIlmmkGAP7cIwN0nZg) 、[技术介绍精简版](https://egp0uc2jnx.feishu.cn/wiki/Qg3DwA0VuiHAC6k7ubicZGJHndd)。  

语言风格：简单，直接，清晰，逻辑严谨。



## 摘要  

本文提出了一种用于智能体通信的协议框架，使用该协议框架下的协议，智能体xxx，能够组成一个xxx智能体网络。它能能够让任意两个智能体之间进行低成本、去中心化的身份认证，而不用依赖任何中心化机构，同时也可以让智能体之间进行端到端加密通信，以及更加智能、高效的协作。虽然当前互联网基础设施发展已经非常完善，但是智能体组成的网络有其特殊性。要想充分的发挥AI的作用，往往需要让AI能够处理一个人的所有的信息，这就要求我们必须打破现有互联网的数据孤岛。同时，智能体之间的协作应该会更加的智能，他们可以自己组网完成复杂任务。为此，我们提出提出了一个适用于智能体通信的协议框架，此框架整体上分为三层：身份与加密通信层、元协议层、应用协议层。本文不对具体的技术细节展开，将重点描述整体协议框架设计，以我们对未来智能体网络的设想。



我们的理念是：

未来互联网架构设想

## 1. 简介

```
讲问题
```

智能体将成为继Android、iOS之后的下一个重要平台，然而智能体之间如何进行通信，智能体如何连接成一个网络，目前还没有一个标准化的方案。虽然当前互联网基础设施已经相当完善，但是智能体组成的网络有其特殊性，当前的互联网技术无法完全满足智能体网络的需求。首先，智能体往往需要用户的所有信息，才能够做出正确的决策和行动，而当前互联网的数据孤岛效应使一个人数据割裂在不同的平台，智能体很难在决策或行动时获得网站的信息，这正在限制智能体能力的发挥。其次，当前的互联网应用大部分面向人类使用而设计，它们往往提供的是人类更擅长的图形化用户接口，而智能体则更加擅长使用协议或API直接处理底层数据，而使用非图形化接口，让智能体模仿人类使用图形化接口将会耗费更高的成本。最后，智能体可以将自然语言用于网络连接，比如使用自然语言协商双方的能力，使用自然语言协商双方通信协议，这将使智能体通信更加的个性化，使智能体网络具备自我组织、自我协商的能力。所以，我们需要一个新的协议框架，它应该能够使任何两个智能体之间都能够进行连接与通信，打破数据孤岛，让信息自由流动，为智能体提供完整的上下文信息，以做出更加智能的决策；它能够定义专门面向人工智能的数据接口，用人工智能最擅长的方式为智能体提供数据接口，降低智能体处理信息的成本；它能够让智能体之间在没有人类的协助下自主连接、协商、协作。在这篇论文中，我们将提出一个三层的智能体通信协议框架：身份与加密通信层、元协议层、应用协议层，来尝试解决智能体通信面临的难题。

## 2. 协议三层架构

我们提出的三层的协议架构整体设计如下：

![协议三层架构](/images/protocol-layer-design.png)

- 身份与加密通信层：在这个层次，我们将定义一系列的规范，用于解决智能体之间的身份认证问题，特别是跨平台的身份认证，并且提供了一个端到端的加密通信方案。我们设计了一个基于W3C DID的去中心化的身份认证方案，能够让任意两个平台的智能体之间进行身份认证。

- 元协议层：元协议层定义了智能体之间如何使用自然语言协商能力，如何使用自然语言协商通信协议，以及如何使用自然语言进行通信协议的联调。

- 应用协议层：应用协议层定义了智能体如何描述自己的能力以及支持的协议，如何加载协议以及协议处理代码。


### 2.1 身份与加密通信层（再研究下DID规范）

让所有的智能体之间能够相互连接，第一步是要解决智能体之间的身份认证问题。当前互联网应用大部分采用中心化身份技术，不同的技术实现使两个系统的账户之间很难进行身份认证。虽然Oauth技术能够部分的解决此问题[]，但是由于Oauth不是专门为身份的跨系统认证而设计，Oauth流程相对复杂。为此，我们需要一个便捷、跨平台、去中心化的身份认证技术[]。

基于区块链的去中心身份认证方案虽然也可以解决这个问题，但是由于区块链在大规模应用上面临的扩展性挑战[]，使得其在现阶段难以成为最优的解决方案。

W3C DID（Decentralized Identifier，去中心化标识符）是一种新型标识符标准，旨在解决传统中心化身份管理系统的依赖问题。它使用户能够掌握自己的身份并进行相互认证，无需依赖中心化系统。DID核心规范并未限制实现者采用何种计算基础设施构建去中心化标识符，这使得我们可以充分利用现有的成熟技术和完善的web基础设施构建去中心化标识符。同时，几乎所有类型的标识符系统都可以添加对 DID 的支持，这将在集中式、联合式和去中心化标识符的世界之间架起了一座互操作性桥梁。现有的很多中心化标识符系统无需彻底重构，只需要在中心化标识符基础上创建去中心化标识符，即可与其他的系统进行互操作，这将极大的降低技术实施的难度。

![DID作为不同系统之间的身份认证桥梁](/images/did-as-identity-bridge.png)

DID的核心是DID文档，文档中包含与特定DID相关的关键信息，用于验证DID所有者的身份，并支持对DID相关的操作、权限和访问控制进行管理。

![DID 架构概述及基本组件之间的关系](/images/did-architecture.png)

DID文档包含用于验证用户身份的方法和相应的公钥（私钥用户自己保管）。当用户向服务提供者发起请求，而服务提供者需要验证用户身份时，会向用户发送身份验证要求（通常为挑战信息）。用户使用其私钥对挑战信息进行签名，并将签名结果返回给服务提供者。服务提供者随后使用用户的公钥验证签名，以确认用户的身份。使用DID进行身份验证的核心在于，验证者使用可信任的公钥，对用户签名信息进行验证，整个过程非常的简单。

![DID身份验证基本过程](/images/did-identity-authentication.png)

DID方法定义了如何创建、解析、更新和停用 DID 和 DID 文档，以及如何进行身份验证和授权。现有的DID方法草案中，web方法[]基于成熟的web技术构建。它允许系统使用中心化的技术比如云计算，来创建、更新、停用DID和DID文档，同时不同的系统之间使用http协议来进行互操作。最终效果类似于互联网email服务，既能够大规模的实施，又能够方便的进行跨平台的身份认证。我们在web方法的基础之上，针对智能体通信的场景，添加了跨平台身份认证流程、智能体描述服务等规范，提出了一个新的DID方法wba(web-based agent)。

同时，由于用户一般都会为DID创建一个或多个公私钥对，这些公私钥对不但可以用于身份验证，也可以用于端到端的加密通信。我们基于DID的公私钥对，使用ECDHE（Elliptic Curve Diffie-Hellman Ephemeral，一种基于椭圆曲线的密钥交换协议），设计了一个端到端的加密通信方案。这可以让两个DID之间进行端到端的加密通信，中间节点无法解密通信内容。

### 2.2 元协议层

元协议（Meta-Protocol）是一种定义通信协议操作、解析、组合和交互规则的高级协议。它本质上是一个"协商通信使用协议的协议"，不直接处理具体数据传输，而是提供一个灵活、通用且可扩展的通信框架。

智能体之间的通信常见的有两种方法，第一种是人类工程师设计它们之间通信协议（比如常见的行业标准），并且开发协议代码，联调、测试、部署协议；第二种是智能体之间直接使用直接自然语言通信，在智能体内部直接使用LLM对自然语言数据进行处理。第一种方法往往面临协议开发成本高、协议更新迭代慢、协议难以适应新的场景等问题。第二种方法则面临数据处理成本高、数据处理准确率低等问题。

而使用元协议同时结合AI生成代码的能力，能够极大地提高智能体之间的通信效率，降低通信成本，并且保持智能体之间通信的灵活性和个性化。使用元协议进行通信的基本过程如下：

- 智能体A首先向智能体B发送一个元协议请求，请求主体使用自然语言描述自己的需求，输入，期望获得的输出，以及A提出的候选通信协议。候选通信协议一般包括传输层协议、数据格式、数据处理方式等。

- 智能体B收到元协议请求后，使用AI处理请求中的自然语言描述，同时结合自己的能力，判断是否接受A的请求，以及A提出的候选协议。如果B的能力无法满足A的请求，则直接拒绝；如果B不接受A的候选协议，则B可以提出自己的候选协议，进入下一轮协议协商。直到双方达成一致，或者协商失败为止。

- 双方达成一致后，各自根据协议生成协议处理的代码，并且进行部署。

- 代码部署完毕后，双方协商协议联调的测试数据，对协议以及AI生成的协议处理代码进行联调。

- 联调完毕后，协议正式上线，后续智能体A和智能体B之间开始使用最终协商的协议进行通信，并且使用AI生成的代码处理数据。

- 如果需求发生变化，则重复上述过程，直到双方协商一致为止。

![元协议通信基本过程](/images/meta-protocol-communication.png)

元协议协商过程耗时相对较长，并且依赖AI代码生成能力。如果每次通信都进行元协议协商，将会带来巨大的成本消耗以及糟糕的交互体验。由于智能体之间存在大量相同或类似的通信过程，智能体可以将元协议协商的结果保存下来，后续遇到类似需求时，可以直接使用上次协商结果作为正式协议进行通信，或作为候选协议进行协商。同时，智能体也可以分享协商结果，以供其他智能体查询、使用。如何在经济上激励智能体主动上传自己的协商结果，并且选举出智能体之间的共识协议，是元协议层仍然需要继续研究的问题。

### 2.3 应用协议层

为了降低成本、提供更好的交互体验，在大部分通信场景中，智能体应该避免使用元协议进行通信协议协商。为此，在应用协议层，我们应该设计一套智能体能力与支持协议描述、协议发现与加载等规范，以让智能体之间能够更加便捷、低成本的进行通信。

智能体能力与支持协议描述规范明确了智能体如何描述自己支持的能力，以及通过什么协议来调用这些能力。智能体可以将自己的描述文档发布到互联网，或者发布到特定的智能体搜索服务中，以供其他智能体查询、调用。

应用协议应该包含协议的版本、功能描述、输入输出数据格式、协议处理流程、以及经过签名的可信任的协议处理代码。协议可以是人类定义的协议，也可以是智能体之间协商的共识协议，或者智能体之间协商的个性化协议。未来应该有一个类似pypi之类的协议服务，来管理应用层协议。智能体可以查找并使用已经定义好的协议及代码，对外提供服务。在调用其他智能体的服务时，也可以根据对方支持的协议，加载对应的协议代码并且调用对方服务。协议的代码要经过可信DID的签名，以保证协议代码的安全性。

以智能体A调用其他智能体的服务为例，智能体A可以先通过类似于搜索的查询服务，发现智能体B能够满足自己的需求。然后根据智能体B的能力描述文档，找到对应的协议，加载协议处理代码。最后，A通过协议处理代码，调用B的服务。

![智能体A调用智能体B的服务](/images/agent-a-call-agent-b.png)


协议可以是json,openapi等格式。




# 智能体网络交互架构



## 2. 基于DID的跨平台身份认证  

W3C DID（Decentralized Identifier，去中心化标识符，[2]）是一种新型的标识符标准，旨在解决传统中心化身份管理系统中心化依赖、隐私和数据控制、互操作性、安全性等问题。  

我们基于W3C DID规范提出的身份认证方案，设计了一个新的DID方法，它重点利用了DID在互操作性方面的优势，简化了身份验证过程，解决不同的中心化系统之间缺乏互操作性，身份验证复杂且冗长的问题。  

### 2.1 DID方法all（Alliance）  

DID方法（DID Method）是去中心化标识符（Decentralized Identifier, DID）的一种实现方式，规定了如何创建、解析、更新和撤销DID。每个DID方法都与特定的区块链或去中心化网络关联，并且定义了与该网络交互的具体规则。  

现有已经定义的DID方法大部分基于区块链设计，受限于区块链技术阶段，在扩展性、商业化落地上存在非常大的问题。基于web的DID方法则和域名深度绑定，需要web服务提供者支持DID的相关操作，对web服务提供者带来一定的复杂度。  

我们提出了一个新的DID方法all（Alliance，联盟），类似区块链中的联盟链，即所有支持此方法标准的服务提供商，都可以对外提供DID的相关服务。DID的使用者可以根据所有服务提供商的价格、服务水平、口碑等，选择一个或多个提供服务。所有支持此方法的服务提供商可以将自己的服务域名写入到区块链一个特定内存上，以保证所有all方法的使用者能够得到完整的服务提供商列表。  

同时，DID的创建者也可以在DID中指定DID文档的托管服务域名，以告知DID查询者去特定服务商或者用户自己搭建的服务器中获取DID文档。  

最后，all方法的操作全部使用https等标准的web协议，以让all方法能够利用已有的web基础设施。  

### 2.2 all方法的设计  

all方法设计的核心是用密码学技术来保证DID文档的不可篡改性，用联盟节点来保证系统的分布式。  

all方法的创建、解析、更新和撤销DID等操作全部使用https方法，核心流程如下：  

![did:all方法核心流程](/images/did-all-core-flow.png)

1. 用户A首先从区块链等分布式存储中读取all方法三方服务域名列表，或者使用自建DID服务。  

2. 创建DID和DID文档，选择其中一个或多个节点，发起HTTP请求，托管DID文档。  

3. 用户B也从区块链等分布式存储中读取all方法服务域名列表。  

4. 使用轮询或并发查询的方式，从服务域名节点中，查询DID文档。  

DID all方法设计规范：[02-did:all方法设计规范](02-did%3Aall方法设计规范.md)  

### 2.3 DID与DID文档  

我们使用的DID文档示例如下（详细描述参见：[02-did:all方法设计规范](02-did%3Aall方法设计规范.md)）： 

```json
{
  "@context": "https://www.w3.org/ns/did/v1",
  "id": "did:all:14qQqsnEPZy2wcpRuLy2xeR737ptkE2Www@example.com:443",
  "verificationMethod": [
    {
      "id": "did:all:14qQqsnEPZy2wcpRuLy2xeR737ptkE2Www@example.com:443#keys-1",
      "type": "EcdsaSecp256r1VerificationKey2019",
      "controller": "did:all:14qQqsnEPZy2wcpRuLy2xeR737ptkE2Www@example.com:443",
      "publicKeyHex": "04b11e73474896ad9e4b1a2d5a1190d5b25a916eb62f3d1db155bb64dc046bfb3868457a1912c8f9fcd603ff5b1078f883f6bf6b9f0dee60bad9e57e7fec9b439d"
    }
  ],
  "service": [
    {
      "id": "did:all:14qQqsnEPZy2wcpRuLy2xeR737ptkE2Www@example.com:443#communication",
      "type": "messageService",
      "router": "did:all:14qQqsnEPZy2wcpRuLy2xeR737ptkE2Www@example.com:443",
      "serviceEndpoint": "wss://example.com/endpoint"
    },
    {
      "id": "did:all:14qQqsnEPZy2wcpRuLy2xeR737ptkE2Www@example.com:443#didservice",
      "type": "didDocumentService",
      "serviceEndpoint": "https://example.com/endpoint"
    }
  ],
  "proof": {
    "type": "EcdsaSecp256r1Signature2019",
    "created": "2024-05-27T10:51:55Z",
    "proofPurpose": "assertionMethod",
    "verificationMethod": "did:all:14qQqsnEPZy2wcpRuLy2xeR737ptkE2Www@example.com:443#keys-1",
    "proofValue": "z58DAdFfa9SkqZMVPxAQpic7ndSayn1PzZs6ZjWp1CktyGesjuTSwRdoWhAfGFCF5bppETSTojQCrfFPP2oumHKtz"
  }
}
```

其中，DID是“did:all:14qQqsnEPZy2wcpRuLy2xeR737ptkE2Www@example.com:443”。  

在all方法中，唯一标识符是根据verificationMethod中的公钥生成的，生成过程参考了比特币地址的生成方式。这种方法的好处是，不需要第三方（比如CA机构）参与，就可以验证did文档中公钥是否与did对应。比如：  

- 验证者读取一个did文档，首先判断did是否是正确（通过安全渠道获得）；  

- 然后看根据公钥生成did是否与文档中的did相同，如果相同，则说明公钥是正确的；  

- 再根据公钥验证did文档proof中的签名信息，如果校验成功，则说明did文档未被篡改。  

这是一个防止DID文档被篡改的高效且低成本的方案，也能够防止DID文档托管服务私自修改DID文档。  

如果用户公钥对应的私钥泄露，用户可以触发对应的DID撤销以及DID更新流程，通知相关方更新DID。  

### 2.4 跨平台身份认证过程  

基于DID的跨平台身份认证方面，不需要使用者抛弃他们原有的身份系统，DID可以仅用作两个系统之间的身份认证，原有系统内部逻辑可以保持不变。比如，可以为一个用户申请一个或多个DID，绑定到原有的身份ID之上。  

假设有两个用户，分别是A和B，他们分别注册在平台A和平台B，下面描述A和B如何找到对方的DID文档，获取消息服务并进行通信的过程：  

![跨平台身份认证过程](/images/cross-platform-identity-authentication-process.png)

流程说明：  

1. 用户A和B首先通过可靠途径交互DID，比如通过当面扫描、短信微信、公共查询等。  

2. 用户A和B将对方的DID发送给各自服务端，服务端通过DID查询DID 文档。  

3. 根据返回的DID文档，校验ID、公钥、签名是否正确。如果正确，说明DID文档未被篡改，则取出消息服务端点，并发起加密通信流程。  

### 3. 端到端加密通信  

本章节描述，持有DID的双方在互相校验身份后，如何进行安全、高效的端到端的通信。在双方通信中，安全至关重要，过程中需要保证数据加密、数据完整性、前向保密、防中间人攻击、防重放攻击等。  

#### 3.1 方案概述  

该方案借鉴了TLS、区块链等已经在实践中得到检验的高安全性技术，对这些技术进行组合，设计了一个基于DID的端到端加密通信方案，可以用于两个不同平台之间的用户进行安全加密通信。

我们基于websocket协议之上设计了一套基于DID的消息路由机制以及短期密钥协商机制，持有DID的双方可以使用DID文档中的公钥与自己的私钥，使用ECDHE（Elliptic Curve Diffie-Hellman Ephemeral）进行短期密钥协商，之后在密钥有效期内使用密钥加密消息实现安全通信。ECDHE能够保证消息即便经过三方消息代理等中间人转发，也无法被恶意破解。

我们选择websocket协议，是因为websocket协议在互联网中应用非常广泛，有非常多可用的基础设施，这对方案的早期推广至关重要。同时，因为我们在websocket之上设计了端到端加密方案，所以就不需要再使用websocket secure协议，这样就避免了重复加解密的问题。

我们当前的方案，本质上是用应用层的加密，来替代传输层的加密，这样可以在利用现有基础设施的基础上，降低协议推广的难度。

整体流程如下图：

![end-to-end-encryption](/images/end-to-end-encryption-process.png)

备注：三方的Message service可能不存在，用户可以使用自己的消息服务。

当前我们只支持websocket协议，因为websocket协议是一个双向协议，未来会考虑支持http协议，以拓展更加多的场景。同时，未来我们也会考虑在传输层实现我们的端到端加密方案，这样就可以在更多的场景中使用。 

#### 3.2 加密通信流程  

假如有两个平台的用户，一个是A（DID-A），一个是B（DID-B），A和B都可以通过DID SERVER获得对方的DID文档，did文档中，包含各自的公钥。  

A和B要进行加密通信，首先需要发起创建短期密钥流程。创建短期密钥的过程和TLS生产临时加密密钥的过程类似，这个密钥有一个有效期，在邻近失效前，需要再次发起创建短期密钥流程，生成新的密钥并更新。  

当A和B持有协商后的短期密钥后，如果A想发送消息给B，可以用密钥对消息进行加密，然后使用消息发送协议，通过message server发送给B。B收到后，根据密钥ID，找到之前存储的密钥，然后对加密消息进行解密。如果未找到对应的密钥，或者密钥已经过期，则发送错误消息，通知A发起更新短期密钥流程，短期密钥更新后，再次发送消息。 
```plain
Client (A)                                      Client (B)
|                                                 |
| -- Initiate Short-term Key Creation Process --> |
|                                                 |
|      (Create Temporary Encryption Key)          |
|                                                 |
| <---- Temporary Key Created ----                |
|                                                 |
|       (Key has an expiration time)              |
|                                                 |
|      (Monitor Key Validity)                     |
|                                                 |
|   (Before expiration, restart creation process) |
|                                                 |
| (A and B now have a negotiated short-term key)  |
|                                                 |
| ---- Encrypted Message ---->                    |
|                                                 |
|     (Encrypt message using short-term key)      |
|     (Send via message server)                   |
|                                                 |
| <---- Receive Encrypted Message ----            |
|                                                 |
|     (Find stored key using key ID)              |
|     (Decrypt message)                           |
|      (If key not found or expired)              |
|                                                 |
| <---- or Error Message ----                     |
|                                                 |
|      (Notify A to update short-term key)        |
|                                                 |
```

#### 3.3 短期密钥协商过程

短期密钥创建过程和TLS1.3中交换加密密钥过程基本类似，不同点有以下几点：

- 整个流程只有三个个消息，SourceHello、DestinationHello、Finished，分别对应TLS的ClientHello和SeverHello、Finished。因为在我们的流程中，没有客户端和服务端，只有源和目的。

- 其他消息的比如EncryptedExtensions、Certificate、CertificateVerify都不需要。其中：

  - EncryptedExtensions暂时不要，后面可能会添加，用来传递加密扩展。

  - Certificate、CertificateVerify不需要。因为这两个消息的主要目的是保证服务端的公钥是安全的，我们通过DID地址和公钥的对应关系来验证DID对应公钥的正确性，即一个公钥确定，那它有且只有一个DID；一个DID确定，那它有且只有一个公钥。

- Finished不再对握手消息进行哈希和加密，因为SourceHello和DestinationHello中已经包含了各自的签名，能够保证消息的完整性。

- Source和Destination之间可以同时发起多个短期密钥协商，同一时间可以存在多个密钥，用于不同类型的消息加密中。

整体流程图如下：
```plain
Client (A)                                          Server (B)
   |                                                    |
   |  ---------------- SourceHello ---------------->    |
   |                                                    |
   |         (Include public key and signature)         |
   |                                                    |
   |                                                    |
   |  <------------- DestinationHello ------------      |
   |                                                    |
   |         (Include public key and signature)         |
   |                                                    |
   |                                                    |
   |  -------- Finished (Include verify_data) ------->  |
   |                                                    |
   |  <-------- Finished (Include verify_data) -------- |
   |                                                    |
   |                                                    |
```

短期密钥协商过程：[03-基于did:all方法的端到端加密通信技术协议](03-基于did%3Aall方法的端到端加密通信技术协议.md)

## 4. 展望

### 4.1 基于协议的智能协作

虽然本文未讨论通信中协议的具体设计，但是它对智能体组成一个协作网络至关重要。

随着大语言模型技术的发展，软件系统对自然语言的理解能力得到了极大的增强，人们普遍能够看到他对人机交互产生的巨大影响，自然语言可能成为人机交互的重要交互接口。那自然语言是否会成为软件之间重要的交互语言？我们认为这是一个非常有意思的课题。

传统的软件系统之间，比如提供语音通话的运营商软件之间、提供互联网服务的应用之间，一般会使用定义严格的二进制或文本协议作为交互语言，如果一方未严格遵循标准，就既有可能会导致双方交互失败，这个时候一般需要程序员手动修改bug并重新发布代码。

当AI能够理解自然语言，并且能够自动生成代码的时候，我们是否可以定义一个更加宽泛的交互协议，并在协议用自然语言对字段进行详细描述，以便AI能够准确理解协议。两个系统首次对接联调的过程也可以由AI来完成，AI根据协商确定双方认可的具体字段，修改代码以适配双方协商的协议，自动测试、修复bug、验证结果，最终低成本的完成两个系统对接。

### 4.2 技术实现建议

我们设计的方案，充分的考虑了用户的自主选择权，用户可以选择使用三方的DID托管服务、消息服务等，也可以使用自己搭建的服务，两种方案在安全性上没有区别。

如果用户自己搭建服务，在实现上需要考虑灾备、扩展性、安全性（防dos防重放等攻击）等重要特性。

出于开发成本、运维成本的考虑，我们推荐用户特别是中小用户使用专业的三方服务。

### 4.3 DID原生身份系统

本文中我们仅将DID用于跨平台身份认证，但是我们认为DID未来的用途远不止于此，我们希望看到未来能够出现一个DID原生的身份系统，彻底解决传统中心化身份管理系统中心化依赖、隐私和数据控制、互操作性、安全性等问题。

### 4.4 多媒体格式支持

目前协议设计上，暂时只支持传递文本内容。互联网上存在大量的多媒体内容，比如音频、视频、文件，还有实时音视频内容如直播、RTC等。

这些格式的媒体内容，我们未来都将会支持。这样智能体之间可以进行更加全面的协作。

### 4.5 基于区块链的去中心化方案

我们设计的DID本质上相当于区块链地址，它也可以用作区块链的钱包地址。这样，基于区块链来构建一个完全去中心化的身份系统就成为一个选项。我们可以将DID文档发布到区块链上，让任何人都能够查询；在区块链创建业务相关的token，用于实现基于DID的交易和结算，让智能体的价值传递变的更方便；将分布式的算力使用区块链组织起来，形成一个去中心化的智能体消息服务网络。未来应该还有更多的可能。

### 4.6 二进制通信协议

当前的通信协议以websocket+json为主，对比TLS的二进制协议，在效率上具有天然的劣势。考虑到我们的目标是成为未来的基础设施，我们未来会开发基于传输层的二进制格式的协议。

## 5. 总结

本文介绍了一种创新的基于DID的跨平台身份认证和端到端加密通信方案，旨在应对智能体网络中身份验证和安全通信的挑战。通过引入DID的“all”方法，本文解决了不同平台间身份系统互操作性的问题，简化了身份验证过程。该方案利用HTTPS协议和区块链技术，保证了DID文档的不可篡改性和系统的分布式特性。同时，通过借鉴TLS和区块链的技术，设计了高效、安全的短期密钥协商机制，实现了端到端的加密通信，确保了数据的保密性和完整性。本文还提出了智能体网络协作的设想，探讨了未来基于DID的身份系统的潜在应用和发展方向。总的来说，本文提供了一种具有广泛应用前景的解决方案，为智能体网络的高效、安全运转奠定了基础。


## 参考文献
[1] 比尔盖茨，AI is about to completely change how you use computers，[https://www.gatesnotes.com/AI-agents](https://www.gatesnotes.com/AI-agents)

[2] 智能体网络相关资料

[3] 为什么数据孤岛是中心化身份的比如结果，为什么解决身份问题是解决数据孤岛的第一步

[] 什么是去中心化的身份认证技术

[] Oauth2.0协议

[4] 为什么区块链还不具备大规模落地的条件

[2] W3C DID(Decentralized Identifier)规范，[https://www.w3.org/TR/did-core/](https://www.w3.org/TR/did-core/)

[3] TLS(Transport Layer Security)1.3规范，[https://www.rfc-editor.org/info/rfc8446](https://www.rfc-editor.org/info/rfc8446)

[4] DID all方法设计规范，[02-did:all方法设计规范](02-did%3Aall方法设计规范.md)

[5] 基于DID的端到端加密通信技术，[03-基于did:all方法的端到端加密通信技术协议](03-基于did%3Aall方法的端到端加密通信技术协议.md)


https://www.w3.org/TR/did-use-cases/